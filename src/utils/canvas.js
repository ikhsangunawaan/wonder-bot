const { createCanvas, loadImage, registerFont } = require('canvas');
const path = require('path');

class CanvasUtils {
    constructor() {
        this.width = 800;
        this.height = 600;
    }

    async createIntroductionCard(user, cardData) {
        const canvas = createCanvas(this.width, this.height);
        const ctx = canvas.getContext('2d');

        // Create gradient background
        const gradient = ctx.createLinearGradient(0, 0, this.width, this.height);
        gradient.addColorStop(0, cardData.favorite_color || '#7C3AED');
        gradient.addColorStop(1, this.darkenColor(cardData.favorite_color || '#7C3AED', 0.3));
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, this.width, this.height);

        // Add subtle pattern overlay
        ctx.globalAlpha = 0.1;
        this.drawPattern(ctx);
        ctx.globalAlpha = 1;

        // Main content background
        const contentX = 50;
        const contentY = 50;
        const contentWidth = this.width - 100;
        const contentHeight = this.height - 100;

        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.roundRect(contentX, contentY, contentWidth, contentHeight, 20);
        ctx.fill();

        // Add shadow
        ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 5;

        // Profile picture placeholder/avatar
        const avatarSize = 120;
        const avatarX = contentX + 40;
        const avatarY = contentY + 40;

        try {
            const avatar = await loadImage(user.displayAvatarURL({ extension: 'png', size: 256 }));
            ctx.save();
            ctx.beginPath();
            ctx.arc(avatarX + avatarSize/2, avatarY + avatarSize/2, avatarSize/2, 0, Math.PI * 2);
            ctx.closePath();
            ctx.clip();
            ctx.drawImage(avatar, avatarX, avatarY, avatarSize, avatarSize);
            ctx.restore();
        } catch (error) {
            // Fallback: draw colored circle with initials
            ctx.fillStyle = cardData.favorite_color || '#7C3AED';
            ctx.beginPath();
            ctx.arc(avatarX + avatarSize/2, avatarY + avatarSize/2, avatarSize/2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const initials = cardData.name.split(' ').map(n => n[0]).join('').toUpperCase();
            ctx.fillText(initials, avatarX + avatarSize/2, avatarY + avatarSize/2);
        }

        // Reset shadow
        ctx.shadowColor = 'transparent';

        // Text content
        const textX = avatarX + avatarSize + 30;
        const textStartY = avatarY + 20;
        let currentY = textStartY;

        // Name
        ctx.fillStyle = '#1F2937';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(cardData.name, textX, currentY);
        currentY += 40;

        // Age and Location
        ctx.font = '18px Arial';
        ctx.fillStyle = '#6B7280';
        ctx.fillText(`${cardData.age} years old â€¢ ${cardData.location}`, textX, currentY);
        currentY += 40;

        // Bio section
        currentY = contentY + 200;
        ctx.fillStyle = '#1F2937';
        ctx.font = 'bold 20px Arial';
        ctx.fillText('About Me:', contentX + 40, currentY);
        currentY += 35;

        ctx.font = '16px Arial';
        ctx.fillStyle = '#374151';
        const bioLines = this.wrapText(ctx, cardData.bio, contentWidth - 80);
        bioLines.forEach(line => {
            ctx.fillText(line, contentX + 40, currentY);
            currentY += 25;
        });

        // Hobbies section
        currentY += 20;
        ctx.fillStyle = '#1F2937';
        ctx.font = 'bold 20px Arial';
        ctx.fillText('Hobbies & Interests:', contentX + 40, currentY);
        currentY += 35;

        ctx.font = '16px Arial';
        ctx.fillStyle = '#374151';
        const hobbiesLines = this.wrapText(ctx, cardData.hobbies, contentWidth - 80);
        hobbiesLines.forEach(line => {
            ctx.fillText(line, contentX + 40, currentY);
            currentY += 25;
        });

        // Decorative elements
        this.addDecorations(ctx, cardData.favorite_color || '#7C3AED');

        // Wonder bot branding
        ctx.fillStyle = '#9CA3AF';
        ctx.font = '12px Arial';
        ctx.textAlign = 'right';
        ctx.fillText('Generated by Wonder Bot', this.width - 20, this.height - 20);

        return canvas.toBuffer('image/png');
    }

    wrapText(ctx, text, maxWidth) {
        const words = text.split(' ');
        const lines = [];
        let currentLine = words[0];

        for (let i = 1; i < words.length; i++) {
            const word = words[i];
            const width = ctx.measureText(currentLine + ' ' + word).width;
            if (width < maxWidth) {
                currentLine += ' ' + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        }
        lines.push(currentLine);
        return lines;
    }

    drawPattern(ctx) {
        const patternSize = 20;
        for (let x = 0; x < this.width; x += patternSize) {
            for (let y = 0; y < this.height; y += patternSize) {
                ctx.fillStyle = 'white';
                ctx.fillRect(x, y, 2, 2);
            }
        }
    }

    addDecorations(ctx, color) {
        // Add some decorative circles
        ctx.fillStyle = color + '20';
        ctx.beginPath();
        ctx.arc(this.width - 100, 100, 30, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(this.width - 50, this.height - 100, 20, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(100, this.height - 80, 25, 0, Math.PI * 2);
        ctx.fill();
    }

    darkenColor(color, percent) {
        // Simple color darkening function
        const num = parseInt(color.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent * 100);
        const R = (num >> 16) - amt;
        const G = (num >> 8 & 0x00FF) - amt;
        const B = (num & 0x0000FF) - amt;
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
            (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
            (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }

    // Add roundRect polyfill if not available
    roundRect(ctx, x, y, width, height, radius) {
        if (typeof ctx.roundRect === 'function') {
            return ctx.roundRect(x, y, width, height, radius);
        }
        
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
    }
}

// Monkey patch roundRect if not available
if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
        this.beginPath();
        this.moveTo(x + radius, y);
        this.lineTo(x + width - radius, y);
        this.quadraticCurveTo(x + width, y, x + width, y + radius);
        this.lineTo(x + width, y + height - radius);
        this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        this.lineTo(x + radius, y + height);
        this.quadraticCurveTo(x, y + height, x, y + height - radius);
        this.lineTo(x, y + radius);
        this.quadraticCurveTo(x, y, x + radius, y);
        this.closePath();
    };
}

module.exports = CanvasUtils;